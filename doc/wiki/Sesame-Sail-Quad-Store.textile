!https://github.com/tinkerpop/gremlin/raw/master/doc/images/openrdf-logo.png!:http://www.openrdf.org

"OpenRDF":http://www.openrdf.org is the creator of the "Sail":http://www.openrdf.org/doc/sesame2/2.3.0/users/ch08.html interface (Storage and Inference Layer). Any triple or quad-store developer can implement the Sail interfaces in order to allow third-party developer to work with different stores without having to change their code. This is very handy as different RDF-store implementations are optimized for different types of use cases. In analogy, Sail is like the "JDBC":http://java.sun.com/javase/technologies/database/ of the relational database world. 

bq.. The Storage And Inference Layer (Sail) API is a low level System API (SPI) for RDF stores and inferencers. Its purpose is to abstract from the storage and inference details, allowing various types of storage and inference to be used. The Sail API is mainly of interest for those who are developing Sail implementations, for all others it suffices to know how to create and configure one. There are several implementations of the Sail API, for example the MemoryStore which stores RDF data in main memory, and the NativeStore which uses dedicated on-disk data structures for storage. (source "OpenRDF Sesame Users Guide":http://www.openrdf.org/doc/sesame2/2.3.0/users/index.html)

p. Many triple and quad-store developers have implemented the Sail interface. Any such stores can be manipulated with Gremlin through their Sail implementations. Here is a list of aspects of RDF that should be understood when dealing with Gremlin over an RDF store.

# *No duplicate edges*: RDF considers two edges the same if they share the same subject, predicate, object, and graph. Thus, edges with these in common are, in fact, the same edge.
# *No indices*: There are no indices as no elements have properties that can not be accessed simply by using @g:id-v(graph?, object)@.
# *Infinite vertices*: RDF is edge based and as such, every possible vertex exists. It is only when finding outgoing or incoming edges to some vertex do you recognize it within a larger graph structure. For this reason, you can not iterate over all vertices in the graph.

The following functions are provided in the @sail@ namespace and only work with Sail based graphs (see @SesameGraph@). Please see [[Handling Graphs]] for more information on working with graph functions. Finally, be sure to visit this "documentation":http://wiki.github.com/tinkerpop/blueprints/sesame-sail-quad-store in order to learn more about how RDF is modeled as a property graph.

# "Sail Functions":#sail_functions
  ** @graph sail:open(string?)@
  ** @null sail:add-ns(graph?, string, string)@
  ** @null sail:remove-ns(graph?, string)@
  ** @map sail:get-ns(graph?)@
  ** @string sail:ns(graph?, string)@
  ** @string sail:prefix(graph?, string)@
  ** @boolean sail:load(graph?, string, string, string?)@
  ** @list sail:sparql(graph?, string)@

h2(#sail_functions). Sail Functions

h3. Open @graph sail:open(string?)@

This function opens a Sail repository. If no string parameter is provided, then a new MemoryStore repository is created. If a string parameter is provided, then the string must be a directory for where to load a NativeStore repository or to create a new NativeStore repository.

bc. gremlin> $_g := sail:open()
==>sailgraph[memorystore]

bc. gremlin> $_g := sail:open('/tmp/native')                     
==>sailgraph[nativestore]

h3. Add Namespace @null sail:add-ns(graph?, string, string)@

This function adds a new prefix and namespace to the provided graph.

bc. gremlin> sail:add-ns('tg', 'http://tinkerpop.com#')
gremlin> sail:get-ns()
==>rdfs=http://www.w3.org/2000/01/rdf-schema#
==>foaf=http://xmlns.com/foaf/0.1/
==>tg=http://tinkerpop.com#
==>xsd=http://www.w3.org/2001/XMLSchema#
==>owl=http://www.w3.org/2002/07/owl#
==>rdf=http://www.w3.org/1999/02/22-rdf-syntax-ns#

h3. Remove Namespace @null sail:remove-ns(graph?, string)@

This function removes a registered namespace by its prefix.

bc.  gremlin> sail:add-ns('tg', 'http://tinkerpop.com#')
gremlin> sail:remove-ns('tg')
gremlin> sail:get-ns()                               
==>rdfs=http://www.w3.org/2000/01/rdf-schema#
==>foaf=http://xmlns.com/foaf/0.1/
==>xsd=http://www.w3.org/2001/XMLSchema#
==>owl=http://www.w3.org/2002/07/owl#
==>rdf=http://www.w3.org/1999/02/22-rdf-syntax-ns#

h3. Get Namespaces @map sail:get-ns(graph?)@

This function returns a prefix-to-namespace map for the provided graph. All Sail-based graphs come with "RDF":http://www.w3.org/1999/02/22-rdf-syntax-ns, "RDFS":http://www.w3.org/2000/01/rdf-schema, "XSD":http://www.w3.org/2001/XMLSchema, "OWL":http://www.w3.org/2002/07/owl, and "FOAF":http://xmlns.com/foaf/0.1/ as pre-loaded namespaces.

bc. gremlin> sail:get-ns()
==>rdfs=http://www.w3.org/2000/01/rdf-schema#
==>foaf=http://xmlns.com/foaf/0.1/
==>xsd=http://www.w3.org/2001/XMLSchema#
==>owl=http://www.w3.org/2002/07/owl#
==>rdf=http://www.w3.org/1999/02/22-rdf-syntax-ns#

h3. Namespace @string sail:ns(graph?, string)@

This function will expand a prefixed URI to its full namespace form. This only works for those prefix/namespace pairs that are registered with the graph.

bc. gremlin> sail:add-ns('tg', 'http://tinkerpop.com#')
==>true
gremlin> sail:ns('tg:marko')
==>http://tinkerpop.com#marko
gremlin> sail:ns('xx:test')
==>xx:test

h3. Prefix @string sail:prefix(graph?, string)@

This function will prefix the provided URI. This only works for those prefix/namespace pairs that are registered with the graph.

bc. gremlin> sail:add-ns('tg', 'http://tinkerpop.com#')
gremlin> sail:prefix('http://tinkerpop.com#marko')
==>tg:marko
gremlin> sail:prefix('http://unknown.com#marko')  
==>http://unknown.com#marko

h3. Load @boolean sail:load(graph?, string, string, string?)@

This function loads an RDF file into the graph. The first argument is the graph for the data to be loaded into. The second argument is the location of the file. The third argument is the RDF file format. The forth and final argument is the base URI for any local reference URIs in the directory. The supported RDF file formats are "RDF/XML":http://www.w3.org/TR/REC-rdf-syntax, "N-Triples":http://www.w3.org/2001/sw/RDFCore/ntriples, "Turtle":http://www.dajobe.org/2004/01/turtle, "N3":http://www.w3.org/DesignIssues/Notation3, "TriX":http://www.w3.org/2004/03/trix, and "TriG":http://www4.wiwiss.fu-berlin.de/bizer/TriG. Note that some of these formats only support triple-based RDF.

bc. gremlin> $_g := sail:open()
==>sailgraph[memorystore]
gremlin> sail:add-ns('tg', 'http://tinkerpop.com#')
gremlin> sail:load('data/graph-example-1.ntriple', 'n-triples')
==>true
gremlin> $_ := g:id-v('tg:1')
==>v[http://tinkerpop.com#1]
gremlin> ./outE
==>e[tg:1 - tg:knows -> tg:2]
==>e[tg:1 - tg:age -> "29"^^<xsd:int>]
==>e[tg:1 - tg:created -> tg:3]
==>e[tg:1 - tg:knows -> tg:4]
==>e[tg:1 - tg:name -> "marko"^^<xsd:string>]

h3. SPARQL @list sail:sparql(graph?, string)@

This function executes a "SPARQL":http://www.w3.org/TR/rdf-sparql-query/ query on the provided Sail-based graph. The results of the function is a list of maps. Each map provides a binding set from a string key to a vertex value for the desired wildcarded results. The graph used for the example below is diagrammed in [[Modeling RDF as a Property Graph]].

bc. gremlin> $_g
==>sailgraph[memorystore]
gremlin> $bs := sail:sparql('SELECT ?x ?y WHERE { ?x tg:knows ?y }')
==>{y=v[http://tinkerpop.com#2], x=v[http://tinkerpop.com#1]}
==>{y=v[http://tinkerpop.com#4], x=v[http://tinkerpop.com#1]}
gremlin> $bs[0]
==>y=v[http://tinkerpop.com#2]
==>x=v[http://tinkerpop.com#1]
gremlin> $bs[0]/@y
==>v[http://tinkerpop.com#2]
gremlin> $bs[0]/@y/outE
==>e[tg:2 - tg:age -> "27"^^<xsd:int>]
==>e[tg:2 - tg:name -> "vadas"^^<xsd:string>]
gremlin> sail:sparql('SELECT ?x ?y WHERE { ?x tg:knows ?y }')[0]/@y/outE
==>e[tg:2 - tg:age -> "27"^^<xsd:int>]
==>e[tg:2 - tg:name -> "vadas"^^<xsd:string>]