[[https://github.com/tinkerpop/gremlin/raw/master/doc/images/gremlin-pipe.png]]

Gremlin provides graph traversal related syntactic sugar to "Groovy":http://groovy.codehaus.org/. Groovy provides dynamic language syntactic sugar to "Java":http://www.java.com/. This section will focus specifically on Gremlin syntax in order to make it easier to understand how Gremlin works. However, realize that anything you can do in Java or Groovy can be done in Gremlin.

*NOTE*: Please refer to [[Gremlin Steps]] for particular information on steps.

h2. Gremlin and Pipes

Gremlin uses property-based, dot notation to chain together different pipes from "Pipes":http://pipes.tinkerpop.com. In Gremlin, a pipe is called a step and a multi-step chain is called a pipeline. For example, @outE.inV@ is a two-step pipeline. The first step will take a vertex and emit its outgoing edges. The second step will take an edge and emit its incoming/head vertex. Gremlin is read left to right where each step can be seen as mapping from an object of one type to an object of another.

h2. Filtering

The unique feature of property graph traversal is the ability to filter out particular paths through a graph. To do this, filter-based steps are used. The generic filter step is @filter@. However, there are numerous shorthands that are outlined below.

* Numeric Array: @outE[10]@ will emit the 11th edge in the step.
* Range Array: @outE[0..10]@ will emit the first 11 edges in the step.
* Map Array: @outE[ [weight:1.0]]@ will emit all edges with a weight property equal to 1.0. 
* Closure: @outE{it.label=='knows' | it.weight > 0.5}@ will emit all edges with a label equal to 'knows' or weight greater than 0.5.

Please read about [[Path Optimizations]] to understand the efficiency of the different models.

