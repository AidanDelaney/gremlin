A graph automata can be used to recognize paths (i.e. words) in a graph. If from a particular root element there are many paths that satisfy the automaton, then there can be a combinatorial explosion as all such legal paths through the graph are taken. To control such branching, a random walk can be used. Moreover, in the long-run behavior of the repeated or parallel application of automata that recognize the same language, the results of a non-random implementation emerges through convergence.

h2. An Automaton to Recognize Co-Developers

Lets define an automaton that will recognize a "co-developer" relationship in a property graph. In plain English, a co-developer relationship exists between two people if both people worked on the same software project. An automaton to recognize this type of relationship in the alphabet of the loosely described in [[Defining a Property Graph]] would use the following path expression.

bc. path co-developer
  ./outE[@label='created']/inV/inE[@label='created']/outV
  end

Given the simple graph diagrammed in [[Defining a Property Graph]], if the root vertex of the automaton is vertex 1 (i.e. @marko@)  and @co-developer@ is defined as above, then the automaton will start from vertex @1@ and arrive at the sink vertices @4@, @5@, and @1@ by way of the intermediate vertex @3@ ("Linked Process":http://linkedprocess.org). Thus, three legal paths exist. This path can be seen as an "abstract" (non-terminal) relation -- a new definition of adjacency.  In other words, @co-developer@ is generated from the concepts of @created@.

bc. gremlin> $_g := tg:open()
==>tinkergraph[vertices:0]
gremlin> g:load('data/graph-example-1.xml')
==>true
gremlin> $_ := g:id-v(1)
==>v[1]

bc. gremlin> path co-developer
  ./outE[@label='created']/inV/inE[@label='created']/outV
  end
==>true
gremlin> .
==>v[1]
gremlin> ./co-developer
==>v[1]
==>v[4]
==>v[6]
gremlin> $_last/@name                                                             
==>marko
==>josh
==>peter

To complicate our example, lets assume that it is not possible for a vertex to be a co-developer with his or herself. Thus, to represent this notion, augment the path to only include those vertices that are not the root vertex. This is accomplished by appending the @g:except(object+)@ function to the end of the path expression. Note that @$_@ is a reserved variable in Gremlin denoting the root vertex set.

bc. path co-developer
  ./outE[@label='created']/inV/inE[@label='created']/outV[g:except($_)]
  end

This traversal is diagrammed in the image below, where @.@ is vertex @1@ (marko).

!https://github.com/tinkerpop/gremlin/raw/master/doc/images/grammar-example-1.jpg!

bc. gremlin> .                                                                        
==>v[1]
gremlin> ./co-developer
==>v[4]
==>v[6]
gremlin> $_last/@name                                                                           
==>josh
==>peter

If the set of source vertices were the entire set of vertices in the graph, then the result of the traversal would be a new set of edges in the graph denoted @co-developer@. In this way, its possible to generate a new graph from the information contained in the original graph (see [[Graph Rewriting]]). This is the principle of inferring more complicate relations from simpler relations.[1]

By defining an automaton to recognize "co-developer" relationships, you are defining the type of traversal that is legal for a graph automaton to take in the graph. Gremlin is suited for expressing such automaton. Moreover, in order to sample particular regions of a graph, this automaton can randomly select solutions and as such, are known as a grammar-based random walker.[2]

h2. Random Walk Automata on Property Graphs

"Random walks":http://en.wikipedia.org/wiki/Random_walk#Random_walk_on_graphs are used to sample regions of a graph. Instead of traversing a graph by taking all edges from a vertex to other vertices, so on in a breadth-first manner, it is possible to only traverse along a single path. The selection of which path to taken can be randomly determined. This type of graph traversal is known as a random walk. Random walk algorithms have applications to searching and ranking a graph. The benefit of randomly walking a graph is that the solution to the search and rank converges to a stable solution as more walks are taken. If there are not sufficient computational resources, then an approximate solution can be found (see the "Law of Large Numbers":http://en.wikipedia.org/wiki/Law_of_large_numbers).

Grammar-based random walkers are automata that are made to recognize a graph generated by a grammar.[2] Given the @co-developer@ relation defined previously, it is possible to augment the path to only take a particular edge out of the root vertex @1@ (marko) and into the intermediate vertex @2@ (lop). This path is defined as

bc. path co-developer-rand
  ./outE[@label='created'][g:rand-real() > 0.5d]/inV/inE[g:rand-real() > 0.5d]/outV[g:except($_)]
  end

The function @g:rand-real()@ returns a randomly generated real between 0 and 1.0 (see [[Gremlin Function Library]]). Thus, a @created@ edge is chosen with a 50% chance. The same behavior occurs later when selecting an incoming @created@ edge out of @lop@.

bc. gremlin> ./co-developer-rand/@name
gremlin> ./co-developer-rand/@name
==>josh
==>peter
gremlin> ./co-developer-rand/@name
gremlin> ./co-developer-rand/@name
==>josh

fn1. Rodriguez M.A., Shinavier, J., "Exposing Multi-Relational Networks to Single-Relational Network Analysis Algorithms":http://arxiv.org/abs/0806.2274, Journal of Informetrics, volume 4, number 1, pages 29-41, ISSN:1751-1577, Elsevier, doi:10.1016/j.joi.2009.06.004, LA-UR-08-03931, 2009.

fn2. Rodriguez, M.A., "Grammar-Based Random Walkers in Semantic Networks":http://arxiv.org/abs/0803.4355, Knowledge-Based Systems, volume 21, issue 7, pages 727-739, ISSN:0950-7051, Elsevier, doi:10.1016/j.knosys.2008.03.030, LA-UR-06-7791, October 2008. 