There are numerous graph frameworks in both the open and closed-source world. While Gremlin comes with the ability to connect to some of the frameworks, its possible to extend Gremlin to work over others currently not supported. This section will discuss how to do so.

# "Implementing the Blueprints Property Graph Model":blueprints
# "Creating an Open Function and Function Library":functions

h2(#blueprints). Implementing the Blueprints Property Graph Model

The first task in adding a new graph backend to Gremlin is to implement the "Blueprints":http://blueprints.tinkerpop.com "Property Graph Model":http://wiki.github.com/tinkerpop/blueprints/property-graph-model interfaces. Blueprints provides a test suite that allows you to validate your implementation in order to ensure that you implementation complies with the semantics of the property graph model interface methods. This is perhaps the biggest hurdle to overcome. 

Realize that if you wish to add a SAIL-based RDF store (see [[Sesame SAIL Quad Store]]), then you do not need to perform this step as Blueprints already has an implementation of the SAIL interface called @SailGraph@. However, you will need to perform the following two steps.

h2(#functions). Creating an Open Function and Function Library

In order to allow a Gremlin user to access your graph backend, you must provide a Gremlin function that will instantiate the graph (or create a connection to the graph). This function is implemented as a Java class and an example @OpenFunction@ is provided below.

bc. public class OpenFunction extends AbstractFunction<Graph> {
    public Atom<Graph> compute(final List<Operation> arguments, final GremlinScriptContext context) throws RuntimeException {
        if (arguments.size() == 0) {
            return new Atom<Graph>(new ExampleGraph());
        } else {
            throw new RuntimeException(this.createUnsupportedArgumentMessage());
        }
    }
    public String getFunctionName() {
        return "open";
    }
}

If your graph requires some additional parameters (e.g. a directory, IP address, port, etc.), then you can use the @List<Operation> arguments@.

bc. List<Object> objects = FunctionHelper.generateObjects(arguments);

Once you have your "open" function implemented, you need to add it to a @Functions@. The following class is an example extension of a @Functions@.

bc. public class ExampleFunctions extends AbstractFunctions {
    public ExampleFunctions() {
        this.functions.add(new OpenFunction());
    }
    public String getNamespace() {
        return "ex";
    }
}

Once these two classes are in the classpath of the Gremlin user, simply load the newly created @Functions@ as so.

bc. gremlin> include 'com.example.ExampleFunctions'
==>true
gremlin> $_g := ex:open()