Gremlin provides language support for lists, sets, maps (see [[Gremlin Type System]]). This section will present some examples of how to manipulate these structures. All of the presented example functions were originally presented in the [[Gremlin Function Library]] section, but are made concise and easy to read in this section.

h3. Lists

A list is an ordered sequence of objects. It is possible to read, write, and update objects in the list using the following statements.

bc. gremlin> $l := g:list(1,2,3)  
==>1
==>2
==>3
gremlin> $l[1]
==>2
gremlin> g:assign($l,2,30)
==>30
gremlin> $l
==>1
==>2
==>30

It is possible to make maps the objects of lists. Below are some examples of using these more complicated data structures.

bc. gremlin> $l := g:list(1,2,g:map('marko','male','jen','female'))
==>1
==>2
==>{marko=male, jen=female}
gremlin> $l[2]
==>marko=male
==>jen=female
gremlin> $l[2]/@marko
==>male

h2. Sets

A set is an unordered, non-duplicate collection of objects. 

bc. gremlin> $s := g:set(1,2,2,3,3,3)
==>1
==>2
==>3
gremlin> $s[0]
==>1
gremlin> $s[1]
==>2
gremlin> $s[2]
==>3
gremlin> $s[3]
gremlin> 

h3. Maps

A map is an unordered collection of object pairs. Maps have a key (object) and a value (object). There may be duplicate values, but not duplicate keys. Thus, a map can be seen as a function mapping the domain of key objects to the codomain of value objects.

bc. gremlin> $m := g:map()
==>{}
gremlin> $m/@key1 := 10    
==>10
gremlin> $m/@key2 := 20
==>20
gremlin> $m
==>key2=20
==>key1=10
gremlin> $m/@key1
==>10
gremlin> $m/@key1 := $m/@key1 + 20 
==>30
gremlin> $m
==>key2=20
==>key1=30
gremlin> g:values($m)
==>20
==>30
gremlin> g:assign($m,'key with space', 50)
==>50
gremlin> $m
==>key with space=50
==>key2=20
==>key1=30
gremlin> g:get($m,'key with space')
==>50

It is possible to use lists in maps. Below are some examples of dealing with these more complicated data structures.

bc. gremlin> $m := g:map('key1',g:list(1,2), 'key2', g:list(3,4))
==>key2=[3, 4]
==>key1=[1, 2]
gremlin> $m/@key1 
==>1
==>2
gremlin> $m/@key1[1]
==>2

Finally, it is possible to use maps within maps.

bc. gremlin> $m := g:map('key1',g:map('key3','value3'),'key2','value2')
==>key2=value2
==>key1={key3=value3}
gremlin> $m/@key1                                                   
==>key3=value3
gremlin> $m/@key1/@key3
==>value3
