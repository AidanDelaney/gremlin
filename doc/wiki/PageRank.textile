As described in a previous section, [[spreading activation]] is a way to rank a local region of a graph with respect to a root set of vertices !http://chart.apis.google.com/chart?cht=tx&chl=R!. What if the root set of vertices is the entire set of vertices in !http://chart.apis.google.com/chart?cht=tx&chl=V!? In other words, what if !http://chart.apis.google.com/chart?cht=tx&chl=R=V!. If the graph is strongly connected and aperiodic, then spreading activation algorithm converges to the "primary eigenvector":http://en.wikipedia.org/wiki/Eigenvalue,_eigenvector_and_eigenspace#Eigenvalues_of_a_graph of the graph. For those graphs that are not strongly connected or aperiodic, its possible to induce these qualities by overlaying a "teleportation" graph. This is how the now famous "PageRank":http://en.wikipedia.org/wiki/PageRank algorithm works. This section will definite a grammar-based PageRank over the Grateful Dead graph diagrammed in [[Defining a More Complex Property Graph]]. It is advised that you first read about [[grammar-based random walkers]] and [[spreading activation]] as this section is an extension of these sections.

# "Defining PageRank":#defining_pagerank
# "PageRank Over the Followed-By Sub-Graph of the Grateful Dead Graph":#followed_by_pagerank
# "Defining a Jerry Garcia Followed-By Grammar over the Grateful Dead Graph":#jerry_garcia_pagerank

h2(#defining_pagerank). Defining PageRank

Suppose that there exists a walker (i.e. a discrete entity, a "marble"). This walker can only exist at a single vertex at single point in time. However, this walker, at each timestep, traverses to a new vertex that is adjacent to its current vertex as defined by the edges !http://chart.apis.google.com/chart?cht=tx&chl=E! in !http://chart.apis.google.com/chart?cht=tx&chl=G!. This selection of an adjacent vertex is randomly decided by the walker. Suppose that the current vertex does not have an outgoing edge to an adjacent vertex. In such cases, the walker simply "teleports" to a random vertex in !http://chart.apis.google.com/chart?cht=tx&chl=V!. Finally, suppose that at each timestep the walker has a probability !http://chart.apis.google.com/chart?cht=tx&chl=\alpha\in(0,1]! of teleporting to some random vertex in !http://chart.apis.google.com/chart?cht=tx&chl=V!. The probability of finding this walker at a particular vertex at some indefinite time in the future is the ranking created by PageRank given the rules just described. Thus, the PageRank of a graph is the probability distribution that a walker creates. 

h2(#followed_by_pagerank). PageRank Over the Followed-By Sub-Graph of the Grateful Dead Graph

Before defining a complicated grammar, lets perform a PageRank over the explicit @followed_by@ edges of the Grateful Dead graph. This edge is defined as follows.

bc. ./outE[@label='followed_by']

However, we need to randomly select one of the outgoing edges for the walker to take. This is done using @gather@ and the @rand-nat(number?)@ function. Lets create a step that wraps this functionality.

bc. step random
  $rand := .[g:rand-nat(g:count(.))]
  end

The reason @gather@ is needed is because all objects previous to @gather@ need to be aggregated so they can be counted and a random one can be emitted.

bc. ./outE[@label='followed_by']/gather/random

But its not the edge we are arriving to, its the vertex, thus, we need to get the vertex at the head of that edge (i.e. the in-vertex).

bc. ./outE[@label='followed_by']/gather/random/inV

Next, sometimes the walker will need to teleport to a random vertex in !http://chart.apis.google.com/chart?cht=tx&chl=V!. This is accomplished by randomly selecting a vertex. We know that we want to only rank song vertices, so lets select a random vertex from the set of song vertices (as there are also artist vertices in the Grateful Dead graph). If we have vertex property indexing turned on, then we can do the following.

bc. $_ := g:key-v('type', 'song')/gather/random

From these pieces we can now implement the PageRank algorithm. Here is the algorithm all together, where we let the walker walk for 2500 timesteps. Note that this is not the most efficient implementation. For one, with every random selection of a song vertex we are re-querying the index as opposed to saving the set of song vertices in memory as a variable.

bc. $_g := tg:open()
g:load('data/graph-example-2.xml')
$m := g:map()
$_ := g:key-v('type', 'song')/gather/random
repeat 2500
  $jump := false
  if g:count(./outE[@label='followed_by']) > 1l
    $_ := ./outE[@label='followed_by']/gather/random/inV
    g:op-value('+',$m,./@name, 1.0)
  else
    $jump := true
    end
  if g:rand-real() > 0.85d or $jump
    $_ := g:key-v('type', 'song')/gather/random
  end
end

Lets rank the resultant map.

bc. gremlin> g:sort($m,'value',true)
==>DRUMS=44.0
==>PLAYING IN THE BAND=38.0
==>ME AND MY UNCLE=32.0
==>TRUCKING=31.0
==>CUMBERLAND BLUES=29.0
==>PROMISED LAND=29.0
==>THE MUSIC NEVER STOPPED=29.0
==>CASSIDY=26.0
==>DARK STAR=26.0
==>NOT FADE AWAY=26.0
==>CHINA CAT SUNFLOWER=25.0
==>JACK STRAW=25.0
==>TOUCH OF GREY=24.0
==>BEAT IT ON DOWN THE LINE=23.0
==>BERTHA=23.0
...

A classic (i.e. centrally located) set of Grateful Dead songs. As more and more walks are taken, the resultant map converges to the PageRank of the @followed_by@ sub-graph of the Grateful Dead graph. Realize that your results may differ as the algorithm is a random process.

h2(#jerry_garcia_pagerank). Defining a Jerry Garcia Followed-By Grammar over the Grateful Dead Graph

!https://github.com/tinkerpop/gremlin/raw/master/doc/images/jerry-garcia.jpg!

PageRank was defined for single-relational graphs. However, using Gremlin, its possible to create a single-relational graph from the composition of path expressions. In other words, using the explicit information in the graph, its possible create an implicit graph on which to compute a PageRank ranking. In this sub-section, lets find the PageRank of the @followed_by@ edges of the Grateful Dead graph for those songs that are primarily @sung_by@ Jerry Garcia. For those not familiar with the Grateful Dead, "Jerry Garcia":http://en.wikipedia.org/wiki/Jerry_Garcia was one of the lead singers of the Grateful Dead. The code to calculate PageRank over this grammar is identical to the previous sub-sections, but there is a new grammar that is being used. Instead of

bc. ./outE[@label='followed_by']/gather/random/inV

where

bc. step random
  $ret := ./gather[g:rand-nat(g:count(.))]
  end

we will use

bc. (./outE[@label='followed_by']/inV/outE[@label='sung_by']/inV[@name='Garcia']/../..)/gather/random

This is what this path expression does. Given some root vertex (@.@), it will get all the outgoing @followed_by@ edges (denote this set @A@). It will then get the head vertices of those edges in set @A@ (denote this set @B@). Next, it will get the outgoing @sung_by@ edges of those vertices in @B@ (denote this set @C@). For all the vertices at the head of set @C@ (denote this set @D@), it will filter out those whose @name@ property does not match 'Garcia'. It then goes back to those paths that have matched so far two steps ago -- @/../..@. Two steps ago means that given that it is currently at set @D@, it will get the valid results in set @B@. Finally, of the vertices in set @B@, it will randomly select one vertex using @g:rand-nat(number?)@. A diagram is provided below to help explain what the path expression is doing.

!https://github.com/tinkerpop/gremlin/raw/master/doc/images/jerry-followed_by-example.jpg!

Now using the same body of code from previous, but with the new grammar, the resultant ranked map is as follows.

bc. gremlin> g:sort($m,'value',true)
==>CRAZY FINGERS=98.0
==>HES GONE=85.0
==>CHINA CAT SUNFLOWER=79.0
==>BERTHA=76.0
==>UNCLE JOHNS BAND=74.0
==>TERRAPIN STATION=72.0
==>GOING DOWN THE ROAD FEELING BAD=71.0
==>WHARF RAT=71.0
==>EYES OF THE WORLD=65.0
==>COLD RAIN AND SNOW=62.0
==>SHIP OF FOOLS=58.0
==>RAMBLE ON ROSE=53.0
==>CASEY JONES=51.0
==>DARK STAR=47.0
==>DEAL=46.0
...

A classic (i.e. centrally located) set of songs sung primarily by Jerry Garcia.