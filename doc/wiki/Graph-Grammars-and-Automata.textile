An "alphabet":http://en.wikipedia.org/wiki/Alphabet_%28computer_science%29 !http://chart.apis.google.com/chart?cht=tx&chl=\Sigma! is a set of elements from which a "formal language":http://en.wikipedia.org/wiki/Formal_language !http://chart.apis.google.com/chart?cht=tx&chl=\mathcal{L}! can be constructed. A "word":http://en.wikipedia.org/wiki/Formal_language#Words_over_an_alphabet !http://chart.apis.google.com/chart?cht=tx&chl=\omega! in !http://chart.apis.google.com/chart?cht=tx&chl=\mathcal{L}! is a legal sequence of elements from the language's alphabet, such that !http://chart.apis.google.com/chart?cht=tx&chl=\omega%20\in%20\Sigma^*!. It is generally not the case that every combination of the alphabet's elements form a legal word in !http://chart.apis.google.com/chart?cht=tx&chl=\mathcal{L}!. Thus, !http://chart.apis.google.com/chart?cht=tx&chl=\omega\in\mathcal{L}\subseteq\Sigma^*!.

A "grammar":http://en.wikipedia.org/wiki/Formal_grammar is a description of a formal language !http://chart.apis.google.com/chart?cht=tx&chl=\mathcal{L}!. It provides the constraints by which the elements of an alphabet can be combined to create legal words within  !http://chart.apis.google.com/chart?cht=tx&chl=\mathcal{L}!. A mechanical recognizer of words within !http://chart.apis.google.com/chart?cht=tx&chl=\mathcal{L}! is known as an "automata":http://en.wikipedia.org/wiki/Automata_theory. Applying these concepts to property graphs can is useful for querying, ranking, and manipulating aspects of a graph. This section is concerned with the creation of automata that can recognize words in a language in a property graph.

h2. Automata for Graphs

The common conception of a word in a formal language is a linear sequence of elements from the language's alphabet. For example, "regular expressions":http://en.wikipedia.org/wiki/Regular_expression were developed to identify legal strings in an ASCII character sequence (i.e. they define an automata to recognize legal words in !http://chart.apis.google.com/chart?cht=tx&chl=\mathcal{L}!). As character strings, these words have a "left-right" adjacency --- a linear topology. In a graph, words can be created from elements connected in any arbitrary topology.[1] Thus, an automata to recognize a property graph grammar must move in multiple directions to determine a legal word. The following itemization presents the previously defined terms with respect to the property graphs processed by Gremlin.

* *alphabet*: a set of vertices, edges, and properties.
* *word*: a sub-graph of vertices, edges and properties.
* *language*: a set of legal sub-graphs of vertices, edges, and properties.
* *grammar*: a schema that generates sub-graphs in the graph.
* *automata*: a mechanical graph walker that recognizes sub-graphs.

A grammar for the language !http://chart.apis.google.com/chart?cht=tx&chl=\mathcal{L}! that has an alphabet that is within the space of the elements and properties of the Grateful Dead graph (see [[Defining a More Complex Property Graph]]) may specify that a legal word is one which contains a vertex of @type="song"@ connected to a vertex of @type="song"@ by an edge of @label="followed_by"@, such that the tail vertex was of @song_type="original"@ and the head vertex was of @song_type="cover"@. An automata to recognize words of this form would follow the path expression:

bc. .[@type='song' and @song_type='original']/outE[@label='followed_by']/inV[@type='song' and @song_type='cover']

!https://github.com/tinkerpop/gremlin/raw/master/doc/images/grateful-dead-concert2.jpg!

Given the vertex named "Dark Star":http://en.wikipedia.org/wiki/Dark_Star_%28song%29 in the Grateful Dead graph as the root vertex, we can traverse the set of grammatically correct paths emanating from this vertex to a set of sink vertices at the tail end of these paths.

bc. gremlin> $_g := tg:open()
==>tinkergraph[vertices:0]
gremlin> g:load('data/graph-example-2.xml')
==>true
gremlin> $_ := g:key-v('name','DARK STAR')
==>v[89]
gremlin> ./@name
==>DARK STAR
gremlin> .[@type='song' and @song_type='original']/outE[@label='followed_by']/inV[@type='song' and @song_type='cover']
==>v[206]
==>v[127]
==>v[18]
==>v[165]
==>v[12]
==>v[3]
==>v[22]
==>v[26]
gremlin> $_last/@name
==>SING ME BACK HOME
==>MORNING DEW
==>EL PASO
==>ALL ALONG THE WATCHTOWER
==>ME AND MY UNCLE
==>NOT FADE AWAY
==>ME AND BOBBY MCGEE
==>PROMISED LAND

Creating automata that can recognize formal paths in a graph is something that Gremlin was designed to do. Moreover, making use of such automata to search, rank, and manipulate a graph make Gremlin a useful tool for one's graph toolbox.

fn1. Brandenburg, F.J., Skodinis, K., "Finite graph automata for linear and boundary graph languages":http://dx.doi.org/10.1016/j.tcs.2004.09.040, Theoretical Computer Science, volume 332, isssues 1-3, pages 199-232, February 2005.